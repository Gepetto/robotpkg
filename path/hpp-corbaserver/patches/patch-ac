PythonÂ 3 support
ref https://github.com/humanoid-path-planner/hpp-corbaserver/pull/89

--- CMakeLists.txt
+++ CMakeLists.txt
@@ -56,7 +56,7 @@ SETUP_HPP_PROJECT ()
 # Dependencies
 ADD_REQUIRED_DEPENDENCY("omniORB4 >= 4.1.4")
 ADD_REQUIRED_DEPENDENCY("omniDynamic4 >= 4.1.4")
-FINDPYTHON(2.7 EXACT)
+FINDPYTHON()
 IF (NOT CLIENT_ONLY)
   ADD_REQUIRED_DEPENDENCY("hpp-core >= 4")
   ADD_REQUIRED_DEPENDENCY("hpp-constraints >= 4")
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 4caf0cd..4caa6ee 100644
--- src/CMakeLists.txt
+++ src/CMakeLists.txt
@@ -23,9 +23,6 @@ SET(IDL_SOURCES
   tools
   )
 
-# search for python
-FINDPYTHON(2.7 EXACT REQUIRED)
-
 OMNIIDL_INCLUDE_DIRECTORIES(${CMAKE_SOURCE_DIR}/idl)
 INCLUDE_DIRECTORIES(${CMAKE_BINARY_DIR}/src)
 
--- src/hpp/corbaserver/benchmark.py
+++ src/hpp/corbaserver/benchmark.py
@@ -16,6 +16,7 @@
 # hpp-corbaserver.  If not, see
 # <http://www.gnu.org/licenses/>.
 
+from __future__ import print_function
 import numpy as np
 import sys
 
@@ -48,7 +49,10 @@ class _BenchmarkIterator (object):
     def __iter__(self):
         return self
 
-    def next(self): # Python 3: def __next__(self)
+    def next(self): # Python 2 iteration
+        return self.__next__ ()
+
+    def __next__(self): # Python 3 iteration
         if self.start:
             self.newCase = True
             self.start = False
@@ -167,7 +171,7 @@ class Benchmark (object):
 
     def __init__ (self, client, robot, problemSolver):
         ## A list of seed to initialize the random generator.
-        self.seedRange = range (1)
+        self.seedRange = list(range(1))
         ## A list of cases for which benchmarking will be done.
         self.cases = [None]
         ## Number of times one case is repeated (for one seed).
@@ -196,9 +200,9 @@ class Benchmark (object):
             self.client.problem.setRandomSeed (self.seedRange[iter.seedI])
             try:
                 if iter.newCase:
-                    print "======================================================="
-                    print "Case ", self.getCase (iter)
-                    print "======================================================="
+                    print("=======================================================")
+                    print("Case ", self.getCase (iter))
+                    print("=======================================================")
                     self.results['user'].append (initCase (self, self.getCase(iter), iter))
                 self.results['time'].append (self.client.problem.solve ())
                 self.results['pathLength'].append (self.client.problem.pathLength (self.client.problem.numberPaths()-1))
@@ -207,39 +211,39 @@ class Benchmark (object):
                 # write current data to restart at the same point
                 self.current = iter
                 self.writeResume ()
-                print err
-                print "\nOops, something went wrong.\nTo resume at the benchmark just before the crash, use method thisobject.tryResumeAndDelete () before calling method do()\n"
+                print(err)
+                print("\nOops, something went wrong.\nTo resume at the benchmark just before the crash, use method thisobject.tryResumeAndDelete () before calling method do()\n")
                 raise
 
-            print "Solved", iter, "in", self.results['time'][-1]
+            print("Solved", iter, "in", self.results['time'][-1])
         i = 0
         nb = self.iterPerCase * len(self.seedRange)
         for c in self.cases:
             t = np.array (self.results['time'][i:i+nb]).dot (self.toSeconds)
             pl = np.array (self.results['pathLength'][i:i+nb])
             nodes = np.array (self.results['states'])
-            print "====================================================="
-            print "Case", c
-            print "Mean time (s):", np.mean(t)
-            print "Std dev time (s):",  np.std(t)
-            print "Mean number of nodes:", np.mean(nodes)
-            print "Std dev nb nodes:",  np.std(nodes)
-            print "Average length:", np.mean(pl)
-            print "std dev length:", np.std(pl)
-            print "====================================================="
+            print("=====================================================")
+            print("Case", c)
+            print("Mean time (s):", np.mean(t))
+            print("Std dev time (s):",  np.std(t))
+            print("Mean number of nodes:", np.mean(nodes))
+            print("Std dev nb nodes:",  np.std(nodes))
+            print("Average length:", np.mean(pl))
+            print("std dev length:", np.std(pl))
+            print("=====================================================")
             i += nb
         t = np.array (self.results['time']).dot (self.toSeconds)
         nodes = np.array (self.results['states'])
         pl = np.array (self.results['pathLength'])
-        print "====================================================="
-        print "All cases together"
-        print "Mean time (s):", np.mean(t)
-        print "Std dev time (s):",  np.std(t)
-        print "Mean number of nodes:", np.mean(nodes)
-        print "Std dev nb nodes:",  np.std(nodes)
-        print "Average length:", np.mean(pl)
-        print "std dev length:", np.std(pl)
-        print "====================================================="
+        print("=====================================================")
+        print("All cases together")
+        print("Mean time (s):", np.mean(t))
+        print("Std dev time (s):",  np.std(t))
+        print("Mean number of nodes:", np.mean(nodes))
+        print("Std dev nb nodes:",  np.std(nodes))
+        print("Average length:", np.mean(pl))
+        print("std dev length:", np.std(pl))
+        print("=====================================================")
         return t, pl
 
     def getCase (self, iter):
@@ -269,7 +273,7 @@ class Benchmark (object):
         else: fname = filename
         import os
         if os.path.isfile (fname):
-            print "Retrieving datas from file", fname
+            print("Retrieving datas from file", fname)
             self.resumeFrom (fname)
             os.remove (fname)
 
@@ -278,16 +282,16 @@ class Benchmark (object):
         with open (fname, 'r') as f:
             cases = pk.load(f)
             if not cases == self.cases:
-                print "Cases are different.\nValue in file is :", cases, "\nValue in this instance was:\n", self.cases
+                print("Cases are different.\nValue in file is :", cases, "\nValue in this instance was:\n", self.cases)
             self.cases = cases
 
             seedRange = pk.load(f)
             if not seedRange == self.seedRange:
-                print "Seed range is different.\nValue in file is :", seedRange, "\nValue in this instance was:\n", self.seedRange
+                print("Seed range is different.\nValue in file is :", seedRange, "\nValue in this instance was:\n", self.seedRange)
 
             iterPerCase = pk.load(f)
             if not iterPerCase == self.iterPerCase:
-                print "Number of iteration per case is different.\nValue in file is :", iterPerCase, "\nValue in this instance was:\n", self.iterPerCase
+                print("Number of iteration per case is different.\nValue in file is :", iterPerCase, "\nValue in this instance was:\n", self.iterPerCase)
             self.iterPerCase = iterPerCase
 
             self.current = pk.load(f)
@@ -431,7 +435,7 @@ class Benchmark (object):
 
     def __str__(self):
         res = ""
-        for i in xrange(len(self.results['time'])):
+        for i in range(len(self.results['time'])):
             res += "Time (s): " + str(np.array (self.results['time'][i]).dot (self.toSeconds)) \
                     + "\nNumber of nodes: " + str(self.results['states'][i]) \
                     + "\nLength: " + str(self.results['pathLength'][i]) + '\n'
--- src/hpp/corbaserver/client.py
+++ src/hpp/corbaserver/client.py
@@ -39,7 +39,7 @@ class Client:
 
     try:
       obj = self.rootContext.resolve (name)
-    except CosNaming.NamingContext.NotFound, ex:
+    except CosNaming.NamingContext.NotFound as ex:
       raise CorbaError (
         'failed to find the service ``{0}\'\''.format (fullServiceName))
 
@@ -77,7 +77,7 @@ class Client:
       raise CorbaError ('failed to narrow the root context')
 
   def _makeClients (self, serviceId, clients, context):
-    for serviceName, class_ in clients.iteritems():
+    for serviceName, class_ in clients.items():
       self._makeClient (serviceId, serviceName, class_, context)
 
 def _getIIOPurl ():
--- src/hpp/corbaserver/ompl_benchmark_statistics.py
+++ src/hpp/corbaserver/ompl_benchmark_statistics.py
@@ -36,6 +36,7 @@
 
 # Author: Mark Moll, Ioan Sucan, Luis G. Torres
 
+from __future__ import print_function
 from sys import argv, exit
 from os.path import basename, splitext, exists
 import os
@@ -335,7 +336,7 @@ def plotAttribute(cur, planners, attribute, typename):
         colsum = np.sum(measurements, axis=1)
         rows = np.where(colsum != 0)[0]
         heights = np.zeros((1,measurements.shape[1]))
-        ind = range(measurements.shape[1])
+        ind = list(range(measurements.shape[1]))
         legend_labels = []
         for i in rows:
             plt.bar(ind, measurements[i], width, bottom=heights[0],
@@ -352,7 +353,7 @@ def plotAttribute(cur, planners, attribute, typename):
     elif typename == 'BOOLEAN':
         width = .5
         measurementsPercentage = [sum(m) * 100. / len(m) for m in measurements]
-        ind = range(len(measurements))
+        ind = list(range(len(measurements)))
         plt.bar(ind, measurementsPercentage, width)
         xtickNames = plt.xticks([x + width / 2. for x in ind], labels, rotation=30)
         ax.set_ylabel(attribute.replace('_',' ') + ' (%)')
@@ -400,7 +401,7 @@ each planner."""
             for r in runids:
                 # Select data for given run
                 cur.execute('SELECT time, %s FROM progress WHERE runid = %s ORDER BY time' % (attribute,r))
-                (time, data) = zip(*(cur.fetchall()))
+                (time, data) = list(zip(*(cur.fetchall())))
                 timeTable.append(time)
                 dataTable.append(data)
             # It's conceivable that the sampling process may have
--- src/hpp/corbaserver/problem_solver.py
+++ src/hpp/corbaserver/problem_solver.py
@@ -28,13 +28,18 @@ def newProblem (client = None, name = None):
         client.problem.resetProblem()
 
 def _convertToCorbaAny (value):
+    from sys import version_info
+    if sys.version_info.major > 2:
+        integers = (int,)
+    else:
+        integers = (long,int,)
     import CORBA
     t = type(value)
     if t is float:
         return CORBA.Any(CORBA.TC_double, value)
     elif isinstance(value, bool):
         return CORBA.Any(CORBA.TC_boolean, value)
-    elif isinstance(value, (long, int)):
+    elif isinstance(value, integers):
         return CORBA.Any(CORBA.TC_longlong, value)
     elif isinstance(value, str):
         return CORBA.Any(CORBA.TC_string, value)
diff --git a/src/hpp/corbaserver/robot.py b/src/hpp/corbaserver/robot.py
index 836f887..9c6ea8c 100755
--- src/hpp/corbaserver/robot.py
+++ src/hpp/corbaserver/robot.py
@@ -150,7 +150,7 @@ class Robot (object):
         for j in self.jointNames:
             b = self.getJointBounds (j)
             r = self.rankInConfiguration [j]
-            for m, M, i in zip (b [::2], b [1::2], xrange (100000)):
+            for m, M, i in zip (b [::2], b [1::2], range (100000)):
                 if q [r+i] == m or q [r+i] == M:
                     saturated.append ((j, i, q [r+i]))
         return saturated
--- src/hpp/corbaserver/tools.py
+++ src/hpp/corbaserver/tools.py
@@ -33,7 +33,7 @@ def Tools(url = None):
 
     try:
       obj = rootContext.resolve (name)
-    except CosNaming.NamingContext.NotFound, ex:
+    except CosNaming.NamingContext.NotFound as ex:
       raise CorbaError (
         'failed to find the service ``{0}\'\''.format (serviceName))
 
--- src/hpp/test_quaternion.py
+++ src/hpp/test_quaternion.py
@@ -20,7 +20,7 @@ import csv
 from hpp import Quaternion
 
 # Test construction from SO3 matrix
-for _ in xrange (1000):
+for _ in range (1000):
     q1 = Quaternion (np.random.sample (4)).normalize ()
     mat = q1.toRotationMatrix ()
     q2 = Quaternion (mat)
@@ -33,7 +33,7 @@ with open ('./test/add-quaternions.csv', 'r') as f:
     iline=0
     for line in r:
         iline+=1
-        data = map (float, line)
+        data = list(map (float, line))
         q1 = Quaternion (data [0:4])
         q2 = Quaternion (data [4:8])
         q3 = Quaternion (data [8:12])
@@ -47,7 +47,7 @@ with open ('./test/mul-quaternions.csv', 'r') as f:
     iline=0
     for line in r:
         iline+=1
-        data = map (float, line)
+        data = list(map (float, line))
         q1 = Quaternion (data [0:4])
         q2 = Quaternion (data [4:8])
         q3 = Quaternion (data [8:12])
@@ -61,7 +61,7 @@ with open ('./test/sub-quaternions.csv', 'r') as f:
     iline=0
     for line in r:
         iline+=1
-        data = map (float, line)
+        data = list(map (float, line))
         q1 = Quaternion (data [0:4])
         q2 = Quaternion (data [4:8])
         q3 = Quaternion (data [8:12])
@@ -75,7 +75,7 @@ with open ('./test/div-quaternions.csv', 'r') as f:
     iline=0
     for line in r:
         iline+=1
-        data = map (float, line)
+        data = list(map (float, line))
         q1 = Quaternion (data [0:4])
         q2 = Quaternion (data [4:8])
         q3 = Quaternion (data [8:12])
@@ -89,7 +89,7 @@ with open ('./test/transform-quaternions.csv', 'r') as f:
     iline=0
     for line in r:
         iline+=1
-        data = map (float, line)
+        data = list(map (float, line))
         q = Quaternion (data [0:4])
         u = np.array (data [4:7])
         v = np.array (data [7:10])
--- src/hpp/corbaserver/problem_solver.py
+++ src/hpp/corbaserver/problem_solver.py
@@ -139,24 +139,24 @@ class ProblemSolver (object):
     # \{
 
     ## Set initial configuration of specified problem.
-    #	\param dofArray Array of degrees of freedom
-    #	\throw Error.
+    #  \param dofArray Array of degrees of freedom
+    #  \throw Error.
     def setInitialConfig (self, dofArray):
         return self.hppcorba.problem.setInitialConfig (dofArray)
 
     ## Get initial configuration of specified problem.
-    #	\return Array of degrees of freedom
+    #  \return Array of degrees of freedom
     def getInitialConfig (self):
         return self.hppcorba.problem.getInitialConfig ()
 
     ## Add goal configuration to specified problem.
-    #	\param dofArray Array of degrees of freedom
-    #	\throw Error.
+    #  \param dofArray Array of degrees of freedom
+    #  \throw Error.
     def addGoalConfig (self, dofArray):
         return self.hppcorba.problem.addGoalConfig (dofArray)
 
     ## Get goal configurations of specified problem.
-    #	\return Array of degrees of freedom
+    #  \return Array of degrees of freedom
     def getGoalConfigs (self):
         return self.hppcorba.problem.getGoalConfigs ()
 
@@ -514,11 +514,11 @@ class ProblemSolver (object):
 
     ## Get the maximal number of iterations in projection
     def getMaxIterPathPlanning (self):
-	return self.hppcorba.problem.getMaxIterPathPlanning ()
+        return self.hppcorba.problem.getMaxIterPathPlanning ()
 
     ## Set the maximal number of iterations in projection
     def setMaxIterPathPlanning (self, iterations):
-	return self.hppcorba.problem.setMaxIterPathPlanning (iterations)
+        return self.hppcorba.problem.setMaxIterPathPlanning (iterations)
 
     ## Get time out in path planning (in seconds)
     def getTimeOutPathPlanning (self):
@@ -530,11 +530,11 @@ class ProblemSolver (object):
 
     ## Get the maximal number of iterations in projection
     def getMaxIterProjection (self):
-	return self.hppcorba.problem.getMaxIterProjection ()
+        return self.hppcorba.problem.getMaxIterProjection ()
 
     ## Set the maximal number of iterations in projection
     def setMaxIterProjection (self, iterations):
-	return self.hppcorba.problem.setMaxIterProjection (iterations)
+        return self.hppcorba.problem.setMaxIterProjection (iterations)
     ## \}
 
     ## \name Collision Checking
@@ -758,25 +758,25 @@ class ProblemSolver (object):
 
     ## Return nearest neighbour of given input configuration.
     # \param connectedComponentId is the index of a connected component in the roadmap.
-    #	   	     If connectedComponentId is negative, function goes through all
-    #		     connected components looking for the nearest node (configuration).
+    #        If connectedComponentId is negative, function goes through all
+    #        connected components looking for the nearest node (configuration).
     # \param distance returns the one-dimensional distance between \param config and
-    #              computed nearest node (configuration). 
+    #        computed nearest node (configuration). 
     # \sa numberConnectedComponents
     def getNearestConfig (self, randomConfig, connectedComponentId = -1):
-	return self.hppcorba.problem.getNearestConfig (randomConfig, connectedComponentId)
+        return self.hppcorba.problem.getNearestConfig (randomConfig, connectedComponentId)
 
     ## Add a configuration to the roadmap.
     # \param config to be added to the roadmap.
     def addConfigToRoadmap (self, config):
-	return self.hppcorba.problem.addConfigToRoadmap(config)
+        return self.hppcorba.problem.addConfigToRoadmap(config)
 
     ## Add an edge to roadmap. If
     # \param config1, config2 the ends of the path,
     # \param pathId the index if the path in the vector of path,
     # \param bothEdges if FALSE, only add config1 to config2, otherwise, If TRUE. add edges config1->config2 AND config2->config1.
     def addEdgeToRoadmap (self, config1, config2, pathId, bothEdges):
-	return self.hppcorba.problem.addEdgeToRoadmap (config1, config2, pathId, bothEdges)
+        return self.hppcorba.problem.addEdgeToRoadmap (config1, config2, pathId, bothEdges)
 
     ## Clear the roadmap
     def clearRoadmap (self):
