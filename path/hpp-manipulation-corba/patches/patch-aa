Python 3 compatibility
ref https://github.com/humanoid-path-planner/hpp-manipulation-corba/pull/60

--- CMakeLists.txt
+++ CMakeLists.txt
@@ -54,6 +54,7 @@ IF (HPP_DEBUG)
   SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -DHPP_DEBUG")
 ENDIF()
 
+FINDPYTHON()
 ADD_REQUIRED_DEPENDENCY("hpp-corbaserver >= 3")
 IF (NOT CLIENT_ONLY)
   ADD_REQUIRED_DEPENDENCY("hpp-template-corba >= 1.1")
--- src/CMakeLists.txt
+++ src/CMakeLists.txt
@@ -23,10 +23,6 @@ SET(IDL_SOURCES
   robot
 )
 
-
-# search for python
-FINDPYTHON(2.7 EXACT REQUIRED)
-
 INCLUDE(${HPP_CORBASERVER_CMAKE_PLUGIN})
 INCLUDE(${HPP_CORBASERVER_DATAROOTDIR}/hpp-corbaserver/cmake/omniidl.cmake)
 OMNIIDL_INCLUDE_DIRECTORIES(
--- src/hpp/corbaserver/manipulation/constraint_graph.py
+++ src/hpp/corbaserver/manipulation/constraint_graph.py
@@ -17,8 +17,9 @@
 # hpp-manipulation-corba.  If not, see
 # <http://www.gnu.org/licenses/>.
 
+from __future__ import print_function
 from subprocess import Popen
-from constraints import Constraints
+from .constraints import Constraints
 
 ## Association of a numerical constraint with the associated passive joints
 #
@@ -74,12 +75,12 @@ class ConstraintGraph (object):
                 self.graphId = g[0].id
                 self.subGraphId = self.graphId + 1
                 for n in g[1].nodes:
-                    if self.nodes.has_key(n.name):
-                        print "Erasing node", n.name, "id", self.nodes[n.name]
+                    if n.name in self.nodes:
+                        print("Erasing node", n.name, "id", self.nodes[n.name])
                     self.nodes[n.name] = n.id
                 for e in g[1].edges:
-                    if self.edges.has_key(e.name):
-                        print "Erasing edge", e.name, "id", self.edges[e.name]
+                    if e.name in self.edges:
+                        print("Erasing edge", e.name, "id", self.edges[e.name])
                     self.edges[e.name] = e.id
             except:
                 pass
@@ -290,9 +291,9 @@ class ConstraintGraph (object):
     #         \li true: uses the edge target constraint
     #         \li false: uses the edge path constraint
     def setProblemConstraints (self, name, target):
-        if self.nodes.has_key(name):
+        if name in self.nodes:
             id = self.nodes[name]
-        elif self.edges.has_key(name):
+        elif name in self.edges:
             id = self.edges[name]
         else:
             raise RuntimeError ("No node or edge with name {0}".format (name))
@@ -473,14 +474,14 @@ class ConstraintGraph (object):
     ## deleted so you can keep them.
     def display (self, dotOut = '/tmp/constraintgraph.dot', pdfOut = '/tmp/constraintgraph', format = 'pdf', open = True):
         self.graph.display (dotOut)
-        if not self.cmdDot.has_key (format):
+        if format not in self.cmdDot:
             raise TypeError ("This format is not supported. See member cmdDot for supported format.")
         dotCmd = self.cmdDot [format]
         dotCmd.append ('-o' + pdfOut + '.' + format)
         dotCmd.append (dotOut)
         dot = Popen (dotCmd)
         dot.wait ()
-        if open and self.cmdViewer.has_key (format):
+        if open and format in self.cmdViewer:
             viewCmd = self.cmdViewer [format]
             viewCmd.append (pdfOut + '.' + format)
             Popen (viewCmd)
@@ -553,7 +554,7 @@ class ConstraintGraph (object):
     #  \return the name of the node
     def getNode (self, config):
         nodeId = self.client.graph.getNode (config)
-        for n,id in self.nodes.iteritems ():
+        for n,id in self.nodes.items ():
             if id == nodeId: return n
         raise RuntimeError ("No node with id {0}".format (nodeId))
 
--- src/hpp/corbaserver/manipulation/constraint_graph_factory.py
+++ src/hpp/corbaserver/manipulation/constraint_graph_factory.py
@@ -18,7 +18,7 @@
 # <http://www.gnu.org/licenses/>.
 
 import re, abc
-from constraints import Constraints
+from .constraints import Constraints
 
 def _removeEmptyConstraints (problem, constraints):
     return [ n for n in constraints if problem.getConstraintDimensions(n)[2] > 0 ]
@@ -64,9 +64,7 @@ class Rules(object):
 # The behaviour can be tuned by setting the callback functions:
 # - \ref graspIsAllowed (redundant with \ref setRules)
 # - \ref constraint_graph_factory_algo_callbacks "Algorithm steps"
-class GraphFactoryAbstract:
-    __metaclass__ = abc.ABCMeta
-
+class GraphFactoryAbstract(abc.ABC):
     def __init__(self):
 
         ## Reduces the problem combinatorial.
@@ -173,7 +171,7 @@ class GraphFactoryAbstract:
     ## \}
 
     def _makeState(self, grasps, priority):
-        if not self.states.has_key(grasps):
+        if grasps not in self.states:
             state = self.makeState (grasps, priority)
             self.states[grasps] = state
 
@@ -234,9 +232,7 @@ class GraphFactoryAbstract:
 # Child classes are responsible for building them.
 # - \ref buildGrasp
 # - \ref buildPlacement
-class ConstraintFactoryAbstract:
-    __metaclass__ = abc.ABCMeta
-
+class ConstraintFactoryAbstract(abc.ABC):
     def __init__(self, graphfactory):
         self._grasp = dict()
         self._placement = dict()
@@ -251,7 +247,7 @@ class ConstraintFactoryAbstract:
         if isinstance(handle, str): ih = self.graphfactory.handles.index(handle)
         else: ih = handle
         k = (ig, ih)
-        if not self._grasp.has_key(k):
+        if k not in self._grasp:
             self._grasp[k] = self.buildGrasp(self.graphfactory.grippers[ig], None if ih is None else self.graphfactory.handles[ih])
             assert isinstance (self._grasp[k], dict)
         return self._grasp[k]
@@ -263,7 +259,7 @@ class ConstraintFactoryAbstract:
         if isinstance(object, str): io = self.graphfactory.objects.index(object)
         else: io = object
         k = io
-        if not self._placement.has_key(k):
+        if k not in self._placement:
             self._placement[k] = self.buildPlacement(self.graphfactory.objects[io])
         return self._placement[k]
 
@@ -312,11 +308,11 @@ class ConstraintFactory(ConstraintFactoryAbstract):
         pn = g + " pregrasps " + h
         self.graph.createGrasp (n, g, h)
         self.graph.createPreGrasp (pn, g, h)
-        return dict ( zip (self.gfields, (
+        return dict ( list(zip (self.gfields, (
             Constraints (numConstraints = _removeEmptyConstraints(self.graph.clientBasic.problem, [ n, ])),
             Constraints (numConstraints = _removeEmptyConstraints(self.graph.clientBasic.problem, [ n + "/complement", ])),
             Constraints (numConstraints = _removeEmptyConstraints(self.graph.clientBasic.problem, [ pn, ])),
-            )))
+            ))))
 
     def buildPlacement (self, o):
         if self.strict:
@@ -341,16 +337,16 @@ class ConstraintFactory(ConstraintFactoryAbstract):
                     ljs.append(n)
                     q = self.graph.clientBasic.robot.getJointConfig(n)
                     self.graph.clientBasic.problem.createLockedJoint(n, n, q)
-            return dict ( zip (self.pfields, (Constraints (), Constraints (lockedJoints = ljs), Constraints (),)))
+            return dict ( list(zip (self.pfields, (Constraints (), Constraints (lockedJoints = ljs), Constraints (),))))
         if not placeAlreadyCreated:
             self.graph.client.problem.createPlacementConstraint (n, self.graphfactory.contactsPerObjects[io], self.graphfactory.envContacts)
         if not pn in self.graph.clientBasic.problem.getAvailable ("numericalconstraint"):
             self.graph.client.problem.createPrePlacementConstraint (pn, self.graphfactory.contactsPerObjects[io], self.graphfactory.envContacts, width)
-        return dict ( zip (self.pfields, (
+        return dict ( list(zip (self.pfields, (
             Constraints (numConstraints = _removeEmptyConstraints(self.graph.clientBasic.problem, [ n, ])),
             Constraints (numConstraints = _removeEmptyConstraints(self.graph.clientBasic.problem, [ n + "/complement", ])),
             Constraints (numConstraints = _removeEmptyConstraints(self.graph.clientBasic.problem, [ pn, ])),
-            )))
+            ))))
 
     ## This implements relaxed placement manifolds,
     ## where the parameterization constraints is the LockedJoint of
@@ -369,15 +365,15 @@ class ConstraintFactory(ConstraintFactoryAbstract):
                 self.graph.clientBasic.problem.createLockedJoint(jn, jn, q)
         placeAlreadyCreated = n in self.graph.clientBasic.problem.getAvailable ("numericalconstraint")
         if (len(self.graphfactory.contactsPerObjects[io]) == 0 or len(self.graphfactory.envContacts) == 0) and not placeAlreadyCreated:
-            return dict ( zip (self.pfields, (Constraints (), Constraints (lockedJoints = ljs), Constraints (),)))
+            return dict ( list(zip (self.pfields, (Constraints (), Constraints (lockedJoints = ljs), Constraints (),))))
         if not placeAlreadyCreated:
             self.graph.client.problem.createPlacementConstraint (n, self.graphfactory.contactsPerObjects[io], self.graphfactory.envContacts)
         if not pn in self.graph.clientBasic.problem.getAvailable ("numericalconstraint"):
             self.graph.client.problem.createPrePlacementConstraint (pn, self.graphfactory.contactsPerObjects[io], self.graphfactory.envContacts, width)
-        return dict ( zip (self.pfields, (
+        return dict ( list(zip (self.pfields, (
             Constraints (numConstraints = _removeEmptyConstraints(self.graph.clientBasic.problem, [ n, ])),
             Constraints (lockedJoints = ljs),
-            Constraints (numConstraints = _removeEmptyConstraints(self.graph.clientBasic.problem, [ pn, ])),)))
+            Constraints (numConstraints = _removeEmptyConstraints(self.graph.clientBasic.problem, [ pn, ])),))))
 
 ## Default implementation of ConstraintGraphFactory
 #

