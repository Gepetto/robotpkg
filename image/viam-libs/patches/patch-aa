$LAAS: patch-aa 2008/08/06 16:35:04 mallet $

    Fixed a potential memory corruption bug.
    
    When an intermediate filtered image was bigger than the final destination
    image and there was an even number of software filters atfer it, the
    intermediate image was written to the final destination, which
    is too small in that case.
    
    Fix this problem by allocating swap space from another swap bank when
    needed and writing the intermediate image there.

diff --git src/camera.c src/camera.c
index 749be59..0d23187 100644
--- src/camera.c
+++ src/camera.c
@@ -282,7 +282,6 @@ viam_camera_sethwmode(viam_handle_t vh, viam_camera_t camera,
 
   raw = viam_camera_raw(camera);
   cvInitImageHeader(raw, size, depth, channels, IPL_ORIGIN_TL, 4);
-  viam_setswap(raw->imageSize);
 
   warnx("camera %s produces %dx%d images, %d bpp, %d channel%s",
 	viam_camera_name(camera), size.width, size.height,
diff --git src/filter.c src/filter.c
index 39eed88..081cc27 100644
--- src/filter.c
+++ src/filter.c
@@ -1,4 +1,4 @@
-/* $LAAS: filter.c 2008/08/04 12:03:47 mallet $
+/* $LAAS: filter.c 2008/08/06 16:10:44 mallet $
  *
  * Copyright (c) 2007-2008 LAAS/CNRS
  * All rights reserved.
@@ -51,7 +51,8 @@
 
 typedef enum viam_filterdst_t {
   VIAM_FDST_SOURCE,
-  VIAM_FDST_SWAP,
+  VIAM_FDST_SWAP_A,
+  VIAM_FDST_SWAP_B,
   VIAM_FDST_FINAL
 } viam_filterdst_t;
 
@@ -197,10 +198,18 @@ viam_filter_image(viam_handle_t vh, viam_image_t image, IplImage *final)
     /* apply value, depending on the method */
     switch(f->method) {
       case VIAM_FILTER_SOFTWARE:
-	if (f->dst == VIAM_FDST_SWAP)
-	  cvSetData(&f->result, viam_swap(), CV_AUTOSTEP);
-	else
-	  cvSetData(&f->result, final->imageData, final->widthStep);
+	switch(f->dst) {
+	  case VIAM_FDST_SOURCE: break;
+
+	  case VIAM_FDST_SWAP_A:
+	  case VIAM_FDST_SWAP_B:
+	    cvSetData(&f->result, viam_swap(f->dst), CV_AUTOSTEP);
+	    break;
+
+	  case VIAM_FDST_FINAL:
+	    cvSetData(&f->result, final->imageData, final->widthStep);
+	    break;
+	}
 
 	s = filter_funcs[f->type].filter(
 	  vh, image, f->source, &f->result, &f->args, f->data);
@@ -371,6 +380,7 @@ viam_filter_configure(viam_handle_t vh, viam_image_t image, viam_filter_t f)
   viam_geometry_t ngeo, *pgeo;
   viam_filterargs_t nargs;
   viam_filterdst_t dst;
+  IplImage *final;
   int s, count;
 
   /* get initial geometry */
@@ -435,7 +445,6 @@ viam_filter_configure(viam_handle_t vh, viam_image_t image, viam_filter_t f)
     /* initialize image header */
     cvInitImageHeader(&f->result, cvSize(ngeo.width, ngeo.height),
 		      ngeo.depth, ngeo.channels, IPL_ORIGIN_TL, 4);
-    viam_setswap(f->result.imageSize);
 
     /* done */
     f->geom = ngeo;
@@ -449,18 +458,34 @@ viam_filter_configure(viam_handle_t vh, viam_image_t image, viam_filter_t f)
     }
   }
 
-  /* update images destinations for all filters */
-
+  /* configure swap and images destinations for all filters */
   count = 0;
-  for(f = viam_image_flist(image); f; f = f->next)
+  for(f = viam_image_flist(image); f; f = f->next) {
     if (f->method == VIAM_FILTER_SOFTWARE) count++;
-
-  dst = (count%2) ? VIAM_FDST_FINAL : VIAM_FDST_SWAP;
+    if (!f->next) final = &f->result;
+  }
+  dst = (count%2) ? VIAM_FDST_FINAL : VIAM_FDST_SWAP_A;
 
   for(f = viam_image_flist(image); f; f = f->next) {
     f->dst = dst;
+    switch(f->dst) {
+      case VIAM_FDST_SWAP_A:
+      case VIAM_FDST_SWAP_B:
+	viam_setswap(f->dst, f->result.imageSize);
+	break;
+
+      case VIAM_FDST_FINAL:
+	if (f->result.imageSize > final->imageSize) {
+	  f->dst = VIAM_FDST_SWAP_B;
+	  viam_setswap(f->dst, f->result.imageSize);
+	}
+	break;
+
+      case VIAM_FDST_SOURCE: break;
+    }
+
     if (f->method == VIAM_FILTER_SOFTWARE)
-      dst = (dst == VIAM_FDST_FINAL) ? VIAM_FDST_SWAP : VIAM_FDST_FINAL;
+      dst = (dst == VIAM_FDST_FINAL) ? VIAM_FDST_SWAP_A : VIAM_FDST_FINAL;
   }
 
   return 0;
