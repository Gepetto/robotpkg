Add generic interface to ConvexRoi that will also work
 for non convex Roi

---
 include/image/roi.hpp | 48 +++++++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 45 insertions(+), 3 deletions(-)

diff --git a/include/image/roi.hpp b/include/image/roi.hpp
index f570d43..2a8753a 100644
--- include/image/roi.hpp
+++ include/image/roi.hpp
@@ -44,7 +44,16 @@ Let's start with simple convex roi, while  thinking to a general roi
 		/**
 		This class represents a convex 2D Region Of Interest.
 		*/
+
+		struct Pixel
+		{
+			int x, y;
+		 private:
+			int x_end;
+			friend class ConvexRoi;
+		};
 		
+		struct Slice{ int y, x1, x2; };
 		struct ConvexSlice { int x, w; };
 		std::ostream& operator<<(std::ostream &os, ConvexSlice const &c);
 
@@ -57,6 +66,7 @@ Let's start with simple convex roi, while  thinking to a general roi
 				ConvexRoiImpl convex; // convex area, with origin at rect.x,rect.y
 				bool hasConvex;
 				int count_;
+				mutable int y_end;
 			private:
 				void initConvex()
 				{
@@ -77,13 +87,45 @@ Let's start with simple convex roi, while  thinking to a general roi
 				
 				void init(cv::Rect _rect) { rect = _rect; convex.resize(0); hasConvex = false; count_ = rect.width*rect.height; }
 				
-				// accessors
+				// rect interface
 				int y(     ) const { return rect.y; }                                  ///< roi and bounding box top
 				int h(     ) const { return rect.height; }                             ///< roi and bounding box height
 				int x(     ) const { return rect.x; }                                  ///< bounding box left
-				int x(int i) const { return rect.x + (hasConvex ? convex[i-rect.y].x : 0); }  ///< roi left
 				int w(     ) const { return rect.width; }                              ///< bounding box width
+
+				// convex interface
+				private:
+				int x(int i) const { return rect.x + (hasConvex ? convex[i-rect.y].x : 0); }  ///< roi left
 				int w(int i) const { return hasConvex ? convex[i-rect.y].w : rect.width; }    ///< roi width
+				public:
+
+				// generic interface, at slice level
+				void start_slice(Slice &s) const { s.y = rect.y-1; y_end = y()+h(); }
+				bool next_slice(Slice &s) const
+				{
+					++s.y;
+					if (s.y >= y_end) return false;
+					s.x1 = x(s.y);
+					s.x2 = x(s.y)+w(s.y)-1;
+					return true;
+				}
+
+				// most generic interface, at individual pixels level, but harder to use because loses all line consistency
+				void start(Pixel &pix) const { pix.y = y(); pix.x = x(pix.y)-1; pix.x_end = x(pix.y)+w(pix.y); y_end = y()+h(); }
+				bool next(Pixel &pix) const
+				{
+					++pix.x;
+					if (pix.x >= pix.x_end)
+					{
+						++pix.y;
+						if (pix.y >= y_end) return false;
+						pix.x = x(pix.y);
+						pix.x_end = x(pix.y)+w(pix.y);
+					}
+					return true;
+				}
+
+				// more generic accessors
 				int size(  ) const { return w()*h(); }                                 ///< roi size
 				int count( ) const { return count_; }                                  ///< roi elements count
 				bool isIn(jblas::vec2 p) const
@@ -92,7 +134,7 @@ Let's start with simple convex roi, while  thinking to a general roi
 					int px = std::floor(p(0));
 					return (py >= y() && py < y()+h() && px >= x(py) && px < x(py)+w(py));
 				}
-				
+
 				/// union
 				ConvexRoi  operator+ (const ConvexRoi &roi) const 
 				{
-- 
1.8.1.5

