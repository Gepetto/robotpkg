Fix roscpp service call deadlock (fix #149)

https://github.com/ros/ros_comm/issues/149
https://github.com/ros/ros_comm/commit/4e8a495fdbdcf8088ae7cc569c3c0a8a45c9c9b3

--- clients/cpp/roscpp/src/libros/transport/transport_tcp.cpp~	2012-07-17 00:18:36.000000000 +0200
+++ clients/cpp/roscpp/src/libros/transport/transport_tcp.cpp	2013-04-17 16:02:46.172086854 +0200
@@ -554,13 +554,12 @@

 void TransportTCP::socketUpdate(int events)
 {
-  boost::recursive_mutex::scoped_lock lock(close_mutex_);
   {
+    boost::recursive_mutex::scoped_lock lock(close_mutex_);
     if (closed_)
     {
       return;
     }
-  }

   // Handle read events before err/hup/nval, since there may be data left on the wire
   if ((events & POLLIN) && expecting_read_)
@@ -585,15 +584,6 @@
     }
   }

-  {
-    boost::recursive_mutex::scoped_lock lock(close_mutex_);
-
-    if (closed_)
-    {
-      return;
-    }
-  }
-
   if ((events & POLLOUT) && expecting_write_)
   {
     if (write_cb_)
@@ -601,14 +591,6 @@
       write_cb_(shared_from_this());
     }
   }
-
-  {
-    boost::recursive_mutex::scoped_lock lock(close_mutex_);
-
-    if (closed_)
-    {
-      return;
-    }
   }

   if((events & POLLERR) ||
