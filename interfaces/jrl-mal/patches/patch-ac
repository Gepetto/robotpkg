Fix build on x86_64 - matrix size is size_t

--- include/jrl/mal/boostmatrix.hh.orig	2011-04-14 22:17:56.000000000 +0200
+++ include/jrl/mal/boostmatrix.hh	2011-11-01 14:40:54.390276118 +0100
@@ -127,9 +127,17 @@
 	  }
 
 	  /** \brief Get the number of rows. */
-	  inline unsigned int nbRows( void ) const { return matrix.size1();}
+	  inline unsigned int nbRows( void ) const {
+            /* XXX static_cast to avoid modifying the interface, but the
+             * function should probably return size_t here */
+            return static_cast<unsigned int>(matrix.size1());
+          }
 	  /** \brief Get the number of columns. */
-	  inline unsigned int nbCols( void ) const { return matrix.size2();}
+	  inline unsigned int nbCols( void ) const {
+            /* XXX static_cast to avoid modifying the interface, but the
+             * function should probably return size_t here */
+            return static_cast<unsigned int>(matrix.size2());
+          }
 
 	  inline Matrix& setZero( void ) { matrix.clear(); return *this; }
 	  inline Matrix& setIdentity( void  )
@@ -216,7 +224,7 @@
 	  }
 	  inline Matrix transpose( void )  const
 	  {
-	    Matrix At(matrix.size2(),matrix.size1()); return transpose(At);
+	    Matrix At(nbCols(),nbRows()); return transpose(At);
 	  }
 
 	  /** \brief Compute the inverse of the matrix.
@@ -235,8 +243,7 @@
 	    ::boost::numeric::ublas::permutation_matrix<std::size_t>  pm(A.size1());
 
 	    /* Perform LU-factorization. */
-	    int res = lu_factorize(A,pm);
-	    if( res!=0 )
+	    if( lu_factorize(A,pm)!=0 )
 	      {
 		fprintf( stderr,"!! %s(#%d)\tError while LU: not invertible.\n",
 			 __FUNCTION__,__LINE__); fflush(stderr);
@@ -255,7 +262,7 @@
 	  }
 
 	  inline Matrix inverse( void )  const
-	  { Matrix Ainv(matrix.size2(),matrix.size1()); return inverse(Ainv); }
+	  { Matrix Ainv(nbCols(),nbRows()); return inverse(Ainv); }
 
 
 
@@ -278,13 +285,13 @@
 	    ::boost::numeric::ublas::matrix<FloatType,::boost::numeric::ublas::column_major> I;
 	    if( matrix.size1()>matrix.size2() )
 	      {
-		toTranspose=false ;  NR=matrix.size1(); NC=matrix.size2();
+		toTranspose=false ;  NR=nbRows(); NC=nbCols();
 		I=matrix;
 		_resizeInv(invMatrix.matrix,I);
 	      }
 	    else
 	      {
-		toTranspose=true; NR=matrix.size2(); NC=matrix.size1();
+		toTranspose=true; NR=nbCols(); NC=nbRows();
 		I = trans(matrix);
 		_resizeInv(invMatrix.matrix,I); // Resize the inv of the transpose.
 	      }
@@ -325,10 +332,10 @@
 	    }
 
 
-	    const unsigned int nsv = s.size();
+	    const size_t nsv = s.size();
 	    unsigned int rankJ = 0;
 	    ::boost::numeric::ublas::vector<FloatType> sp(nsv);
-	    for( unsigned int i=0;i<nsv;++i )
+	    for( size_t i=0;i<nsv;++i )
 	      if( fabs(s(i))>threshold ) { sp(i)=1/s(i); rankJ++; }
 	      else sp(i)=0.;
 	    invMatrix.matrix.clear();
@@ -379,7 +386,7 @@
 				       Matrix* U = NULL,
 				       Vector* S = NULL,
 				       Matrix* V = NULL)  const
-	  { Matrix Ainv(matrix.size2(),matrix.size1()); return pseudoInverse(Ainv,threshold,U,S,V); }
+	  { Matrix Ainv(nbCols(),nbRows()); return pseudoInverse(Ainv,threshold,U,S,V); }
 
 
 
@@ -404,13 +411,13 @@
 	    ::boost::numeric::ublas::matrix<FloatType,::boost::numeric::ublas::column_major> I;
 	    if( matrix.size1()>matrix.size2() )
 	      {
-		toTranspose=false ;  NR=matrix.size1(); NC=matrix.size2();
+		toTranspose=false ;  NR=nbRows(); NC=nbCols();
 		I=matrix;
 		_resizeInv(invMatrix.matrix,matrix);
 	      }
 	    else
 	      {
-		toTranspose=true; NR=matrix.size2(); NC=matrix.size1();
+		toTranspose=true; NR=nbCols(); NC=nbRows();
 		I = trans(matrix);
 		_resize(invMatrix.matrix,matrix); // Resize the inv of the transpose.
 	      }
@@ -451,10 +458,10 @@
 
 	    }
 
-	    const unsigned int nsv = s.size();
+	    const size_t nsv = s.size();
 	    unsigned int rankJ = 0;
 	    ::boost::numeric::ublas::vector<FloatType> sp(nsv);
-	    for( unsigned int i=0;i<nsv;++i )
+	    for( size_t i=0;i<nsv;++i )
 	      {
 		if( fabs(s(i))>threshold*.1 )   rankJ++;
 		sp(i)=s(i)/(s(i)*s(i)+threshold*threshold);
@@ -507,7 +514,7 @@
 				       Matrix* U = NULL,
 				       Vector* S = NULL,
 				       Matrix* V = NULL)  const
-	  { Matrix Ainv(matrix.size2(),matrix.size1()); return dampedInverse(Ainv,threshold,U,S,V); }
+	  { Matrix Ainv(nbCols(),nbRows()); return dampedInverse(Ainv,threshold,U,S,V); }
 
 
 
@@ -536,7 +543,7 @@
 	  inline friend Matrix& multiply( const Matrix& A,const Matrix& B,Matrix& C )
 	  { return A.multiply(B,C);    }
 	  inline Matrix multiply( const Matrix& B ) const
-	  {  Matrix C(matrix.size1(),B.matrix.size2()); return this->multiply(B,C); }
+	  {  Matrix C(nbRows(),B.nbCols()); return this->multiply(B,C); }
 	  inline Matrix& multiply( const Matrix& B,Matrix& C ) const
 	  {
 	    MAAL_CHECKVERBOSE(_checksizeProd(matrix,B.matrix));
@@ -549,7 +556,7 @@
 	  friend inline Vector& multiply( const Matrix& M, const Vector& v, Vector& res )
 	  {  return M.multiply(v,res); }
 	  inline Vector multiply( const Vector& v ) const
-	  {  Vector res(matrix.size1()); return this->multiply(v,res); }
+	  {  Vector res(nbRows()); return this->multiply(v,res); }
 	  inline Vector& multiply(  const Vector& v, Vector& res ) const
 	  {
 	    MAAL_CHECKVERBOSE(_checksizeProd(matrix,v.vector));
@@ -563,7 +570,7 @@
 	  inline friend Matrix& addition( const Matrix& A,const Matrix& B,Matrix& C )
 	  { return A.addition(B,C);     }
 	  inline Matrix addition( const Matrix& B ) const
-	  {  Matrix C(matrix.size1(),matrix.size2()); return addition(B,C);}
+	  {  Matrix C(nbRows(),nbCols()); return addition(B,C);}
 	  inline Matrix&	addition( const Matrix& B,Matrix& C ) const
 	  {
 	    MAAL_CHECKVERBOSE(_checksize(matrix,B.matrix));
@@ -575,7 +582,7 @@
 	  inline friend Matrix& substraction( const Matrix& A,const Matrix& B,Matrix& C )
 	  { return A.substraction(B,C); }
 	  inline Matrix substraction( const Matrix& B ) const
-	  { Matrix C(matrix.size1(),matrix.size2()); return substraction(B,C); }
+	  { Matrix C(nbRows(),nbCols()); return substraction(B,C); }
 	  inline Matrix& substraction( const Matrix& B,Matrix& C ) const
 	  {
 	    MAAL_CHECKVERBOSE(_checksize(matrix,B.matrix));
@@ -589,7 +596,7 @@
 	  inline friend Matrix& multiply( const Matrix& A,const FloatType x,Matrix& C )
 	  { return A.multiply(x,C); }
 	  inline Matrix multiply( const FloatType x ) const
-	  { Matrix C(matrix.size1(),matrix.size2()); this->multiply(x,C); return C;}
+	  { Matrix C(nbRows(),nbCols()); this->multiply(x,C); return C;}
 	  inline Matrix& multiply( const FloatType x,Matrix& C ) const
 	  {
 	    //_resize(matrix,C.matrix); multiply(matrix,x,C.matrix);
@@ -600,13 +607,13 @@
 	  inline friend Matrix& addition( const Matrix& A,const FloatType x,Matrix& C )
 	  { return A.addition(x,C);}
 	  inline Matrix addition( const FloatType x ) const
-	  {  Matrix C(matrix.size1(),matrix.size2()); return this->addition(x,C); }
+	  {  Matrix C(nbRows(),nbCols()); return this->addition(x,C); }
 	  inline Matrix& addition( const FloatType x,Matrix& C ) const
 	  {
 	    //_resize(C.matrix,matrix);
 	    C.matrix=matrix;
-	    for(unsigned int i=0;i<matrix.size1();i++)
-	      {for(unsigned int j=0;j<matrix.size2();j++)
+	    for(unsigned int i=0;i<nbRows();i++)
+	      {for(unsigned int j=0;j<nbCols();j++)
 		  C.matrix(i,j) += x;
 	      }
 	    return C;
@@ -616,13 +623,13 @@
 	  inline friend Matrix& substraction( const Matrix& A,const FloatType x,Matrix& C )
 	  { return A.substraction(x,C);  }
 	  inline Matrix substraction( const FloatType x ) const
-	  {  Matrix C(matrix.size1(),matrix.size2()); return substraction(x,C); }
+	  {  Matrix C(nbRows(),nbCols()); return substraction(x,C); }
 	  inline Matrix& substraction( const FloatType x,Matrix& C ) const
 	  {
 	    //_resize(C.matrix,matrix);
 	    C.matrix = matrix;
-	    for(unsigned int i=0;i<matrix.size1();i++)
-	      {for(unsigned int j=0;j<matrix.size2();j++)
+	    for(unsigned int i=0;i<nbRows();i++)
+	      {for(unsigned int j=0;j<nbCols();j++)
 		  C.matrix(i,j) -= x;
 	      }
 	    return C;
@@ -632,13 +639,13 @@
 	  inline friend Matrix& division( const Matrix& A,const FloatType x,Matrix& C )
 	  { return A.division(x,C);}
 	  inline Matrix division( const FloatType x ) const
-	  {  Matrix C(matrix.size1(),matrix.size2()); return division(x,C);}
+	  {  Matrix C(nbRows(),nbCols()); return division(x,C);}
 	  inline Matrix& division( const FloatType x,Matrix& C ) const
 	  {
 	    //_resize(C.matrix,matrix);
 	    C.matrix = matrix;
-	    for(unsigned int i=0;i<matrix.size1();i++)
-	      {for(unsigned int j=0;j<matrix.size2();j++)
+	    for(unsigned int i=0;i<nbRows();i++)
+	      {for(unsigned int j=0;j<nbCols();j++)
 		  //C.matrix(i,j) = matrix(i,j) / x;
 		  C.matrix(i,j) /= x;
 	      }
@@ -699,7 +706,7 @@
 	  }
 	  inline const FloatType& elementAt( const int elmt ) const
 	  {
-	    const int l =  matrix.size1();
+	    const unsigned int l =  nbRows();
 	    const div_t q = div(elmt,l);
 	    const int r = q.quot;
 	    const int c = q.rem;
@@ -707,7 +714,7 @@
 	  }
 	  inline FloatType& elementAt( const int elmt )
 	  {
-	    const int l =  matrix.size1();
+	    const unsigned int l =  nbRows();
 	    const div_t q = div(elmt,l);
 	    const int r = q.quot;
 	    const int c = q.rem;
@@ -730,7 +737,7 @@
 	  { Vector res; getDiagonal(res); return res; }
 	  inline Vector& getDiagonal( Vector& vector ) const
 	  {
-	    const unsigned int MIN = std::min(  matrix.size1(),matrix.size2() );
+	    const unsigned int MIN = std::min(nbRows(), nbCols());
 	    vector.resize( MIN );
 	    for( unsigned int i=0;i<MIN;++i )
 	      vector(i) = matrix(i,i);
@@ -893,8 +900,8 @@
 	      return true;
 	    else
 	      {
-		fprintf(stderr,"!!\tmaal::Matrix: error in matrix size for product [%dx%d] x [%dx%d].\n",
-			mat1.size1(),mat1.size2(),mat2.size1(),mat2.size2()); fflush(stderr);
+               fprintf(stderr,"!!\tmaal::Matrix: error in matrix size for product [%ux%u] x [%ux%u].\n" /*C++ has no %zu*/,
+                       static_cast<unsigned int>(mat1.size1()),static_cast<unsigned int>(mat1.size2()),static_cast<unsigned int>(mat2.size1()),static_cast<unsigned int>(mat2.size2())); fflush(stderr);
 		return false;
 	      }
 	  }
